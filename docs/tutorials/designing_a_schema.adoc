= Tutorial: Designing a Schema

Imagine you want to make an app for shared makerspaces (shared workshops
where everybody can build it's own ideas). How to shape the data for
that application? Lets find out in this tutorial.

== Properties: The basic building blocks
Lets think about what you basically want to do: A portal where people
can connect and find and offer places and instruments.

So you definitly need this entities (we call them nodes or vertices):

* Person
* Workshop
* Tool

And you need properties to define how these nodes can be related (or
connected) to each other:

* belongs to (e.g an tool could belong to a workshop or a person)
* is staff member (e.g. a person could be a staff member of a workshop)

To define this in our schema we could write it like this

[[basic_schema]]
[source, rust]
----
#[derive(Schema)]
#[derive(Debug, PartialEq)]
pub enum OpenWorkShopsSchema {
  Person{ name: String, surname: String},
  Workshop{ name: String },
  Tool(String),

  // connections
  #[schema(additional_types = Connection)]
  BelongsTo,
  #[schema(additional_types = Connection)]
  IsStaffMember,

  // A special type used later for queries
  SchemaType(String),
}
----

With this you can already play and create usefull data.

=== People start using it
Here is Nick. A nice woodworker who would like to share his workshop
and skills to educate others.

He installs you app and adds his workshop to the database.

[source, rust]
----
let nick = db.create_node(Person{ name: "Nick".to_string(), surname: "Nice".to_string() });
let wshop = db.create_node(Workshop{ name: "Nick's Workspace".to_string() });
db.create_edge(wshop, nick, BelongsTo);

let t1 = db.create_node(Tool("Table Saw".to_string()));
db.create_edge(t1, wshop, &BelongsTo);
let t2 = db.create_node(Tool("Miter Saw".to_string()));
db.create_edge(t2, wshop, &BelongsTo);
----

Then there is Allice. She would like to create a new DIY table but she
is missing the tools and the space. So she starts searching who has a
table saw and finds Nick's Workspace.

[source, rust]
----
let result = db.query(Tool("Table Saw").start()
  .referencing_vertices()
  .outgoing()
  .intersect(BelongsTo.start().referencing_edges())
  .outgoing());
----

== Something is missing: Evolving the Schema
However there is a problem. Allice now knows that there is a table saw
available in Nick's Workspace but she does not know where it is located.

[NOTE]
====
This is something common once you start using your applications. You
will find use cases that you had not forseen at the beginning. This is
the reason why the ability to evolve schemas is so important.
====

Just add an additional property `Location` and a connection type
`LocatedAt` to your schema.

[[enhanced_schema]]
[source, rust, highlight=7,14..15]
----
#[derive(Schema)]
#[derive(Debug, PartialEq)]
pub enum BasicPimSchema {
  Person{ name: String, surname: String},
  Workshop{ name: String },
  Tool(String),
  Location{ address: String },

  // connections
  #[schema(additional_types = Connection)]
  BelongsTo,
  #[schema(additional_types = Connection)]
  IsStaffMember,
  #[schema(additional_types = Connection)]
  LocatedAt,

  // A special type used later for queries
  SchemaType(String),
}
----

Now Nick can add the location to his workshop and Allice can find where
it is actually located.

=== It's your turn
Now it's your turn. Play with the schema and add some more useful
features to it. For example it would be nice to see opening hours for a
workshop, contact information, timeslots for tool usage, categories what
kind of work a workshop supports etc.

The possibilities of what you can do with the data are endless.

== Beyond properties: Adding constraints on relations
Currently you can connect your nodes in any form. But not all
connections would make sense. By constraining what makes sense your
application becomes more robust.

For example while a tool could belong to a person or a workshop, it
would not make sense the other way round or for a tool to belong to a
location. You can prevent this by adding the following constraint.

[source, rust]
----
Prohibited(SchemaType("Tool")
  .start()
  .referencing_properties()
  .referencing_vertices()
  .ingoing()
  .intersect(BelongsTo
    .start()
    .referencing_edges()
  )
)
----

And of course it would make no sense add nodes of type `BelongsTo` and
connect them via edges of type e.g. `Tool`. Connections should only be
used for connections and nodes for nodes.

[source, rust]
----
Prohibited(SchemaType("Connection")
  .start()
  .referencing_properties()
  .referencing_vertices()
)
----

== Spoilt for Choice: It's a game of tradeoffs
The schema we have is still relativly simple. However there are already
a lot of things we could have done differently. For example instead
of adding the location as another node type we could have modified
the workshop type to something like `Workshop{ name: String, adress:
String }`. Both options have pros and cons that will be connected with
the use cases that arise. Searching for a location or for a shop could
become easier when both are seperate entities. On the other hand having
everything split up into the most basic enties can become too flexible
so that things become harder to control and understand.

Don't chase for the perfect schema. It's impossible. Things will always
need to be adapted once your understanding of the domain and it's use
cases grows. And the domain itself will change.

Instead learn to evolve and adapt your schemas once your understanding
of the domain deepens (btw the best way to get to a really good schema
soon is not thinking hard, but putting your current schema into real
use. Playing with it. And then improving it).

Learning to evolve schemas is hard. Here are a few things to keep in
mind.

=== Not all of the data is under your control
Once your application becomes useful, people will use it to store data
in it. When you evolve your schema, maybe it's not compatible with the
data already stored in the database.

As a rule of thumb you should NEVER break the data of your users. The
reason why they are using your application is that very data. It's what
makes it precious to them.

Instead version your data schemas (and your data, so that you can find
out which schema version it is compatible with). Then write a migration
for every version to the next one and test those migrations very
carefully.

Especially when the amount of data in your db grows and the db is used
24/7 not all of your data on disk will be of the same version. Make
sure that you can work with both versions while a migration is running.
A similar situation arises when there are multiple installations of
a database (e.g. with open source applications, or when you have
installations for different customers). You can never know which version
the data on disk will have, so be prepared to start a migration if
needed.

TODO Tutorial example of how to write a schema migration for data on disk

=== Not all of your APIs will evolve a the same pace
Imagine your db becomes so useful, other people want to use it on their
own to support their workflows.

When you change your schema now you could break their workflows because
some of their queries would not work anymore (and you won't have control
over their queries). But when you don't change your schema you are stuck
yourself.

To adress this version the schema of your queries (and version it
separately from the schema on disk). When a user uses some old version
of the schema transform it on the fly into the current version.

TODO tutorial example how to write a query transform

This technique can even be useful when you don't have public APIs
because it allows you to have greater modularity in your code.

== Playing with keys to improve performance
By default all keys are
https://en.wikipedia.org/wiki/Universally_unique_identifier[uuids].
This is great because it makes syncing easier. But when you deal with
absolutly sorted data (like e.g. timestamps) you can improve performance
massively by modifying your keys.

TODO tutorial showing how to apply this to time and space search

=== Bringing this to an extreme: Enter the vector space

[NOTE]
====
I don't know if vector databases really work that way. But I am pretty
sure they have some conceptional similaries. +
Definitly you could use this for similar use cases.
====

TODO Tutorial showing how to use semanitc scales in keys combined with
embeddings, to search for similar images, text or files.

