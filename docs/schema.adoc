Data Schema
===========

In our graph storage, you can store any kind of information. Apart
from the division into nodes, connections, and properties, we have no
preconceptions about the structuring of the data.

This leads to a high flexibility, but in a concrete case, more
constraints enable us to make more specific demands on the data types
(what yes, goes hand in hand with restrictions), which makes the
data easier to interpret and process. In other words: The queries
become *more efficient*. As an additional advantage, we can also make
statements about the *contentual correctness* of one or several data
sets.

Creating a https://en.wikipedia.org/wiki/Data_model[data model] through
such a schema is a significant help in understanding both the data and
the domain.

That's why we want to allow defining a
https://de.wikipedia.org/wiki/Schema_(Informatik)[schema] in our
databases.

== Overview
A schema consists of two parts:

* Defining the possible data formats for Properties
* Defining how Nodes, Connections and Properties can/should interact
  with each other

[source, rust]
----
pub struct Schema {
  <<schema_elements>>
}
----

We'll now go through these aspects.

== Possible Data Formats for Properties
Properties are the central elements to define how the data should be
shaped. With them, we determine which building blocks are available in
our graph.

As an analogy, one could imagine atoms (based on the idea that atoms
are the indivisible fundamental building blocks of all matter). We can
combine them to form new materials, but they themselves are initially
given and unchangeable.

[[schema_elements]]
[source, rust]
----
pub trait SchemaElement<K: Sized, E> {
  <<schema_element_functions>>
}
----

In general, all data types can be serialized as an array of bytes (this
is the most generic form in which data is stored on current computers.
Therefore, whatever can be stored in a file on a computer, could also be
serialized as an array of bytes).

When defining our schema, we determine how to deserialize raw data
arrays into data structures so that it can be easily processed later.

[[schema_element_functions]]
[source, rust]
----
fn deserialize(data: &[u8]) -> Result<Self,E> where Self: Sized;
----

Conversely, we also want to be able to convert our structure back again
into a byte array (a file) footnote:[It's important that when you
serialize a structure with `deserialize`, it produces the same original
input structure].

[[schema_element_functions]]
[source, rust]
----
fn serialize(&self) -> Result<Vec<u8>,E>;
----

We also need a function to give us the key of an element. This allows us
later to easily retrieve the corresponding element from the database.

[[schema_element_functions]]
[source, rust]
----
fn get_key(&self) -> K;
----

With this, we can ensure that we can easily query and verify data.

=== Schema Interfaces for Nodes, Connections and Properties
Our database allows us to define a schema. For this to be possible, the
individual elements must provide interfaces.

[[traits]]
[source, rust]
----
pub trait Node<P: Property> {
  fn id(&self) -> uuid::Uuid;
  fn properties(&self) -> P;
}
----

Since we store properties separately from the nodes and connections
themselves, we also define a separate interface for them. This allows us
to share properties between multiple elements.

A unique feature of our properties is that they can reference other
properties as a tree structure.

It is possible to reference files using paths and potentially
synchronize these references. In certain use cases, this can be
very useful and convenient, allowing direct access to images,
videos, etc. using a normal file editor while still maintaining
direct access to the data in the database. However, this also
carries risks, as changes to linked files would not affect the
Property data record, leading to potential invisible conflicts
during synchronization. An alternative would be to store the data
as a blob within the Property data record and provide it through a
https://en.wikipedia.org/wiki/Filesystem_in_Userspace[fuse file system].
This would be safer but might lead to performance issues. Another
possibility would be to establish a mechanism where Properties reference
other Properties in the Store (via hash) and provide these Properties
with files through a Fuse file system. Here, performance could also
become an issue (possibly resolvable), but the data in the Properties
would change less often. What is best will depend heavily on the
specific application case.

TODO die Idee der auf Properties verweisenden Properties könnte viele interessante und nützliche Anwendungen haben.

[[schema_elements]]
[source, rust]
----
pub trait NestableProperty: Sized
{
  fn nested(&self) -> Vec<Self>;
}
----

[[schema_elements]]
[source, rust]
----
pub trait Property<K: Sized, E>: Sized + SchemaElement<K, E> + NestableProperty {}
impl<T: Sized + SchemaElement<K, E> + NestableProperty, K: Sized, E> Property<K, E> for T {}
----

TODO Es waere schoen Iteratoren verwenden zu koennen `fn nested(&self) -> impl Iterator<Item=Self> + '_;` // Siehe https://blog.katona.me/2019/12/29/Rust-Lifetimes-and-Iterators/ und https://depth-first.com/articles/2020/06/22/returning-rust-iterators/

TODO Es ist wichtig irgendwie zu verhindern, dass Properties rekursiv auf sich selbst verweisen (auch nicht indirekt). Sonst kann es passieren, dass sich Schemata nicht validieren lassen (es käme zu endlosen Schleifen).

== Zusammenhänge zwischen Elementen definieren
Wenn man sich das Datenformat für Eigenschaften als Atome vorstellt,
so entspricht der nun folgende Teil, den Regeln nach denen aus Atomen
Moleküle zusammengesetzt werden können.

Mit anderen Worten es geht um die Definition von erlaubten bzw
erforderlichen Strukturen zwischen Elementen.

Zu diesem Zweck verwenden wir Regeln. Immer wenn eine Transaktion (TODO
link) abgeschlossen wird, wird zunächst überprüft, ob alle Regeln
(Constraints) eingehalten wurden. Ist das nicht der Fall wird die
Transaktion verworfen und eine Fehlermeldung mit der Begründung zurück
gegeben.

Diese Reglen lassen sich in zwei Kategorien einordnen:

* Bedingungen, die erfüllt sein *müssen*
* Bedingungen, die *nicht erlaubt* sind. Also nicht auftreten dürfen

Wir verwenden hierfür unsere Zoe Abfrage Sprache (TODO link). Wir
überprüfen jeweils bei einer Abfrage, wie viele Ergebnisse es gibt. Bei
einer geforderten Bedingung muss es mindestens ein Ergebnis geben und
bei einer verbotenen Bedingung darf es kein Ergebnis geben.

[[schema_elements]]
[source, rust]
----
pub enum SchemaConstraint<<generic_types>> {
  Requiered(ql::BasicQuery<<generic_types>>),
  Prohibited(ql::BasicQuery<<generic_types>>),
}
----

TODO Aus Zoe importieren

[[generic_types]]
[source, rust]
----
<VertexId, EdgeId, PropertyId, VFilter, EFilter>
----

== Schema Struktur
Nun können wir alle diese Bausteine in ein gemeinsames Schema
zusammenfassen. Dabei müssen wir Unmengen an generischen Parametern
verschalten.

[[schema_elements]]
[source, rust]
----
pub struct Schema<
  VertexId,
  EdgeId,
  PropertyId,
  VFilter,
  EFilter,
  VertexSchema,
  EdgeSchema,
  PropertySchema,
  E,
>
where
  VertexId: Sized,
  VertexSchema: SchemaElement<VertexId, E>,
  EdgeId: Sized,
  EdgeSchema: SchemaElement<EdgeId, E>,
  PropertyId: Sized,
  PropertySchema: SchemaElement<PropertyId, E>,
{
  pub vertex_properties: VertexSchema,
  pub edge_properties: EdgeSchema,
  pub referenced_properties: PropertySchema,
  pub constraints: Vec<SchemaConstraint<VertexId, EdgeId, PropertyId, VFilter, EFilter>>,
  _err_type: std::marker::PhantomData<E>,
}
----

Aber der Aufwand lohnt sich, denn nun können wir beliebige Schemata
überprüfen.

TODO Funktion, welche am Ende einer Transaktion aufgerufen werden kann um die Gültigkeit der Transaktion zu prüfen.

[source, rust, save]
.src/schema.rs
----
use crate::ql;

<<schema_elements|join="\n\n">>

<<default_implementations|join="\n\n">>
----

== Schema Migrationen
Früher oder später verändert oder erweitert sich das Verständnis der
zugrundeliegenden Domain footnote:[Gründe dafür können unter anderem
sein, dass man die Domain nun besser versteht, dass sie sich verändert
hat (und nicht unser Verständnis) oder das man sie erweitern möchte,
indem man sie mit einer weiteren Domain zusammenführt. Auch können
Performance Bedürfnisse dazu führen, dass man das Schema anpassen
möchte.]. Dann wird man das Schema verändern.

Im Grunde bedeutet das nichts anderes, als das man das bestehende
Schema durch ein neues ersetzt. Die Problematik besteht darin, dass die
bestehenden Daten mit dem alten Schema erzeugt wurden und wir sicher
stellen müssen, dass sie in das neue Schema überführt werden und weiter
alle Bedingungen erfüllt bleiben.

TODO Beschreiben, dass man für jedes Schema eine Version braucht. Dann benötigt man jeweils eine Funktion, welche die Daten von einem Schema der unteren Version in das Schema der nächst höheren Version konvertiert. Bei einer Konvertierungen werden dann alle Funktionen für die dazwischenliegenden Versionen nacheinander ausgeführt.

TODO Mögliche Optimierungen beschreiben. Möglicherweise lassen sich die Konvertierungsfunktionen zusammenfassen, so dass man jeden Knoten und jede Verbindung nur einmal anfassen muss (ob das sicher möglich ist muss allerdings erst noch überprüft werden). Möglicherweise kann man auf die Validierungen zwischen den Konvertierungen verzichten und erst die letzte Validierung durchführen.

== Standard Implementierung
Manchmal ist es nützlich einfach ohne ein spezielles Schema beginnen zu
können. Dadurch wird unsere Datenbank auch verwendbar, ohne das jeder
zuerst ein Schema erdenken und anschließend die Datenbank mit diesem
Schema gemeinsam kompilieren muss. Aus diesem Grund definieren wir ein
sehr allgemeines Schema, welches beliebige Daten (wie bespielsweise
Dateien auf dem Computer) aufnehmen kann. Seine sehr laxe Validierung
erlaubt direkt mit der Datenbank zu arbeiten.

[[default_implementations]]
[source, rust]
.Allgemeines Schema für beliebige Properties
----
use sha2::Digest;
#[cfg(feature="lua")]
use mlua::{FromLua, UserData};

#[derive(Debug, Clone)]
#[cfg_attr(feature = "lua", derive(FromLua))]
pub struct GenericProperty(Vec<u8>);

impl<E> SchemaElement<String, E> for GenericProperty
{
  fn get_key(&self) -> String {
    format!("{:X}", sha2::Sha256::digest(&self.0))
  }

  fn serialize(&self) -> Result<Vec<u8>, E> {
    Ok(self.0.clone())
  }

  fn deserialize(data: &[u8]) -> Result<Self, E>
  where
    Self: Sized,
  {
    Ok(GenericProperty(data.to_vec()))
  }
}

impl NestableProperty for GenericProperty {
  fn nested(&self) -> Vec<Self> { Vec::new() } // <1>
}

#[cfg(feature="lua")]
impl UserData for GenericProperty {}
----
<1> Wir bilden keine Verweise der Dateien untereinander ab, da wir ja
    bei dieser allgemeinen Fassung des Schemas die Dateien selbst gar
    nicht auswerten.

[[default_implementations]]
[source, rust]
----

impl<E> SchemaElement<String, E> for Vec<u8>
{
  fn get_key(&self) -> String {
    format!("{:X}", sha2::Sha256::digest(&self))
  }

  fn serialize(&self) -> Result<Self, E> {
    Ok(self.clone())
  }

  fn deserialize(data: &[u8]) -> Result<Self, E> {
    Ok(data.to_vec())
  }
}

impl NestableProperty for Vec<u8> {
  fn nested(&self) -> Vec<Self> { Vec::new() }
}
----

